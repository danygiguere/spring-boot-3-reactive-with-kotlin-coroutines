# Spring boot 3 reactive with Kotlin coroutines and r2dbc

## About
- This project is just a demo or a starting template to work with Spring boot 3 with Kotlin coroutines and r2dbc and DatabaseClient (https://docs.spring.io/spring-framework/reference/data-access/r2dbc.html)
- The project is set up to work mysql (you can clone this project to create a dockerized db: https://github.com/danygiguere/docker_db)
- If you are using IntelliJ Ultimate, you can run the requests.http file (in the test folder) to test all the available routes
- In this demo I haven't used an orm. If you'd like to use an ORM, have a look at CoroutineCrudRepository. It' is a non-blocking reactive interface for generic CRUD operations using Kotlin Coroutines.
- I recommend you watch this video regarding coroutines : https://www.youtube.com/watch?v=ahTXElHrV0c

### The app demonstrates:
    - how to create controllers, dtos, entities, and repositories with Kotlin coroutines
    - how to set up Flyway to manage migrations
    - how to set an exception handler to manage failed validations
    - how to return translated validation error messages
    - how to create custom validators
    - how to set up the Security with JWT with an httpOnly cookie
    - how to use webfilters to block user from updating data that doesn't belong to them (checkPostOwnershipWebFilter)
    - how to do a oneToMany relationship query
    - how to do a belongsTo relationship query
    - how to do a hasManyThrough relationship query
    - how to run suspend functions in parallel with async/await
    - how to create unit tests in a reactive context
    - how to do webclient calls with Kotlin Coroutines
    - how to create Fixtures and factories to seed the db, and to create dtos data for tests
    - how to run the project in a Docker container using docker-compose (you need to make a copy of .env.example and rename the copy to .env, add your db credentials and then run docker-compose up)

### Installation
    - Add your credentials in the application-secrets.yml file
    - Start the project with ./gradlew bootRun or ./gradlew bootRun -Dspring.profiles.active=local

### Docker
    - This project has a Dockerfile and a docker-compose.yml for deployement on AWS ECS
    - To test locally, you can add the credentials in the .env file and run docker-compose up

### ASW ECS instructions
    - Make sure you have the AWS CLI installed on your machine
    - run gradle clean build
    - to build the image, run docker buildx build --no-cache --pull --platform linux/amd64 -t imagename . 
    - Create an ECR repository and look at the instructions (by clicking on the view push commands button) to push the image to ECR 
        - docker buildx build --no-cache --pull --platform linux/amd64 -t imagename . 
        - aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 123456789012.dkr.ecr.us-east-1.amazonaws.com
        - docker tag imagename:latest 123456789012.dkr.ecr.us-east-1.amazonaws.com/imagename:latest
        - docker push 123456789012.dkr.ecr.us-east-1.amazonaws.com/imagename:latest
    - Create a task definition in ECS
        - https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html
        - Basically, you need to enter a name, the image url (from ECR), the app port and the Environment variables (the ones in the .env)
    - Create a cluster in ECS
        - https://docs.aws.amazon.com/AmazonECS/latest/developerguide/create-a-cluster.html
        - The name is automatically generated by the ECS service, so you only need to click create cluster and then click create.
    - Create a service in ECS
        - https://docs.aws.amazon.com/AmazonECS/latest/developerguide/create-service.html
        - To create a service, go to the task definition page, click your definition, then click Deploy and Create service
        - Choose the lastes task definition, under Compute configuration (advanced), click the Launch type Compute Options. Under Desired tasks, choose 0 and then click create.
        - Once the service is created, you can go to the ECS dashboard, click on the cluster, then click on the service
        - From there you can see the logs and if you click on the Tasks tab, you can see the status of the task and stop it if needed
        - If you click on the task, you'll find the app Public IP under Configuration but you won't be able to acces it yet from the internet
        - Go to the Configuration and networking tab and then on the security groups link
        - Then click on the Edit inbound rules link
        - Then click on the add rule link
        - Choose Custom TCP and enter the app port and under source, choose Anywhere-IPv4
        - Create another rule but for Anywhere-IPv6
        - You should now be able to access the Public IP from the internet